#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model FM3217_2022.Tutorial2.MotorDrive
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Mon Sep 12 13:53:44 2022

   */

#include <matrixop.h>
static double DymArrays1[5]={0.0, 1.0, 1.0, 0.0, 0.0};
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays0[5]={3.0, 2.0, 1.0, 0.0, -1.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
DYMOLA_STATIC int   Modelica_Math_Matrices_isEqual(RealArray   M10_0, RealArray  
   M20_0, double  eps0_0);
struct Modelica_Math_Vectors_interpolate_struct {
  double   yi0_0_0member;
  int   iNew0_0_0member;
};
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Math.Matrices.isEqual
discrete input Real M1[:, :] "First matrix";
discrete input Real M2[:, :] "Second matrix (may have different size as M1)";
discrete input Real eps(start = 0, min = 0.0) "Two elements e1 and e2 of the two matrices are identical if abs(e1-e2) <= eps";
output Boolean result "= true, if matrices have the same size and the same elements";
protected 
Integer nrow(start = size(M1, 1)) "Number of rows of matrix M1";
Integer ncol(start = size(M1, 2)) "Number of columns of matrix M1";
Integer i(start = 1);
Integer j;
public 
algorithm 
result := false;
if (size(M2, 1) == nrow and size(M2, 2) == ncol) then 
result := true;
while i <= nrow loop
j := 1;
while j <= ncol loop
if (abs(M1[i, j]-M2[i, j]) > eps) then 
result := false;
i := nrow;
j := ncol;
end if;
j := j+1;
end while;
i := i+1;
end while;
end if;
end Modelica.Math.Matrices.isEqual;

  */
DYMOLA_STATIC int   Modelica_Math_Matrices_isEqual(RealArray   M10_0, RealArray  
   M20_0, double  eps0_0) {
  PushContext("Modelica.Math.Matrices.isEqual")
  {
    /* Declare outputs and temporaries */
    int   result0_0;
    int   nrow0_0;
    int   ncol0_0;
    int   i0_0;
    int   j0_0;
    MarkObject retmark_ = PushMark();
    result0_0=0;
    nrow0_0 = DYNSizeSimple(M10_0, 1);
    ncol0_0 = DYNSizeSimple(M10_0, 2);
    i0_0 = 1;
    j0_0=0;
    /* Start of real code */
      result0_0 = false;
      if (DYNSizeSimple(M20_0, 1) == nrow0_0 AND DYNSizeSimple(M20_0, 2) == 
        ncol0_0) {
        result0_0 = true;
        while (i0_0 <= nrow0_0) {
          j0_0 = 1;
          while (j0_0 <= ncol0_0) {
            if (fabs(RealElement( M10_0, (SizeType)(i0_0), (SizeType)(j0_0))-
              RealElement( M20_0, (SizeType)(i0_0), (SizeType)(j0_0))) > eps0_0)
               {
              result0_0 = false;
              i0_0 = nrow0_0;
              j0_0 = ncol0_0;
            }
            j0_0 = j0_0+1;
          }
          i0_0 = i0_0+1;
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return result0_0;
  }}

/* Flattened Modelica model:

function Modelica.Math.Vectors.interpolate
discrete input Real x[:] "Abscissa table vector (strict monotonically increasing values required)";
discrete input Real y[size(x, 1)] "Ordinate table vector";
discrete input Real xi "Desired abscissa value";
input Integer iLast(start = 1) "Index used in last search";
discrete output Real yi "Ordinate value corresponding to xi";
output Integer iNew(start = 1) "xi is in the interval x[iNew] <= xi < x[iNew+1]";
protected 
Integer i;
Integer nx(start = size(x, 1));
discrete Real x1;
discrete Real x2;
discrete Real y1;
discrete Real y2;
public 
algorithm 
assert(nx > 0, "The table vectors must have at least 1 entry.");
if (nx == 1) then 
yi := y[1];
else
i := min(max(iLast, 1), nx-1);
if (xi >= x[i]) then 
while i < nx and xi >= x[i] loop
i := i+1;
end while;
i := i-1;
else
while i > 1 and xi < x[i] loop
i := i-1;
end while;
end if;
x1 := x[i];
x2 := x[i+1];
y1 := y[i];
y2 := y[i+1];
assert(x2 > x1, "Abscissa table vector values must be increasing");
yi := y1+(y2-y1)*(xi-x1)/(x2-x1);
iNew := i;
end if;
annotation(smoothOrder=100);
end Modelica.Math.Vectors.interpolate;

  */
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0) {
  PushContext("Modelica.Math.Vectors.interpolate")
  AssertModelica(DYNSizeSimple(y0_0,1)==DYNSizeSimple(x0_0, 1),"size(y, 1) == size(x, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    double   yi0_0;
    int   iNew0_0;
    int   i0_0;
    int   nx0_0;
    double   x10_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    yi0_0=0;
    iNew0_0 = 1;
    i0_0=0;
    nx0_0 = DYNSizeSimple(x0_0, 1);
    x10_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    /* Start of real code */
      AssertModelica(nx0_0 > 0,"nx > 0", "The table vectors must have at least 1 entry.");
      if (nx0_0 == 1) {
        yi0_0 = RealElement( y0_0, (SizeType)(1));
      }
      else{
        i0_0 = IntegerBmin(IntegerBmax(iLast0_0, 1), nx0_0-1);
        if (xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
          while (i0_0 < nx0_0 AND xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0+1;
          }
          i0_0 = i0_0-1;
        }
        else{
          while (i0_0 > 1 AND xi0_0 < RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0-1;
          }
        }
        x10_0 = RealElement( x0_0, (SizeType)(i0_0));
        x20_0 = RealElement( x0_0, (SizeType)(i0_0+1));
        y10_0 = RealElement( y0_0, (SizeType)(i0_0));
        y20_0 = RealElement( y0_0, (SizeType)(i0_0+1));
        AssertModelica(x20_0 > x10_0,"x2 > x1", "Abscissa table vector values must be increasing");
        yi0_0 = y10_0+divGuarded((y20_0-y10_0)*(xi0_0-x10_0),"(y2-y1)*(xi-x1)",
          x20_0-x10_0,"x2-x1");
        iNew0_0 = i0_0;
      }
    /* Output section */
    PopContext()
    {
      struct Modelica_Math_Vectors_interpolate_struct out_;
      out_.yi0_0_0member = yi0_0;
      out_.iNew0_0_0member = iNew0_0;
      return out_;
    }
  }}
/* DSblock C-code: */

#define NX_    7
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    129
#define NP_    33
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -478983778
#define NHash2_ 771015168
#define NHash3_ 0
#define NI_    0
#define NRelF_ 9
#define NRel_  9
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    84
#define SizePre_ 1
#define SizeEq_ 5
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 1
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 72
#define NGlobalHelpI_ 8
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="FM3217_2022.Tutorial2.MotorDrive";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/toma/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[16]={6 , 1 , 1 , 2 , 2 , 4 , 1 , 3 , 1 , 5 , 1 , 6
   , 1 , 7 , 0 , 0};
DYMOLA_STATIC int QJacobianGC_[43]={
1 , 0 , 0 , 0 , 1 , 0 , 0 , 2 , 0 , 0 , 0 , 4 , 0 , 4 , 3 , 0 , 3 , 0 , 0 , 0 , 0
   , 5 , 0 , 0 , 5 , 5 , 0 , 5 , 6 , 6 , 6 , 0 , 0 , 0 , 0 , 7 , 0 , 0 , 0 , 7
   , 7 , 0 , 0};
DYMOLA_STATIC double QJacobianCD_[8]={0  , 44 , 50 , 54 , 70 , 64 , 63 , 60};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,2) = false;
DYNX(W_,10) = false;
DYNX(W_,15) = 3;
DYNX(W_,23) = 1;
DYNX(W_,26) = false;
DYNX(W_,27) = false;
DYNX(W_,41) = false;
DYNX(W_,45) = 4;
DYNX(W_,46) = false;
DYNX(W_,53) = true;
DYNX(W_,61) = true;
memcpy(&DYNX(W_,97), &DymArrays0, sizeof(double)*5);
DYNX(W_,105) = 1;
DYNX(W_,106) = 1;
DYNX(W_,116) = 0.0001;
DYNX(W_,117) = 4;
DYNX(W_,118) = true;
DYNX(W_,125) = 1E-10;
DYNX(W_,127) = 3;
DYNX(W_,22) = 5;
DYNX(W_,28) = 3;
DYNX(W_,34) = 1;
DYNX(W_,47) = 293.15;
DYNX(W_,48) = 293.15;
DYNX(W_,115) = 0;
DYNX(W_,126) = 0;
DYNX(W_,6) = 0;
DYNX(W_,31) = 0;
DYNX(W_,30) = false;
DYNX(W_,128) = 0.0;
DYNX(W_,13) = 0.0;
DYNX(W_,14) = 0.0;
DYNX(W_,119) = 293.15;
DYNX(W_,49) = 293.15;
DYNX(W_,52) = 0.0;
DYNX(W_,51) = 293.15;
DYNX(W_,43) = 0.0;
DYNX(W_,62) = 293.15;
DYNX(W_,7) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,3) = DYNX(DP_,1);
AssertModelica(1+DYNX(DP_,2)*(DYNX(W_,3)-DYNX(DP_,1)) >= 1E-15,"1+electricalMotor.Ra.alpha*(electricalMotor.Ra.T-electricalMotor.Ra.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(DYNhelp,0) = divinvGuarded(DYNX(DP_,8),"PID.Ti");
DYNX(W_,25) = DYNX(DYNhelp,0);
DYNX(W_,29) = DYNX(DP_,11);
DYNX(W_,32) = DYNX(DP_,9);
DYNX(DYNhelp,1) = divinvGuarded(DYNX(DP_,10),"PID.Nd");
DYNX(W_,33) = RealBmax(DYNX(DYNhelp,1)*DYNX(DP_,9), 1E-13);
DYNX(W_,35) = DYNX(DP_,12);
DYNX(DYNhelp,2) = fabs(DYNX(W_,32));
DYNX(W_,37) = DYNX(DYNhelp,2) < 1E-15;
DYNX(W_,38) = DYNX(DP_,7);
DYNX(W_,55) = DYNX(DP_,23);
AssertModelica(fabs(DYNX(W_,55)) > 0,"abs(gearbox.lossyGear.ratio) > 0", 
  "Error in initialization of LossyGear: ratio may not be zero");
DYNX(W_,56) = DYNX(DP_,24);
DYNX(W_,57) = DYNX(DP_,25);
DYNX(W_,58) = DYNX(DP_,26);
DYNX(W_,59) = DYNX(DP_,27);
DYNX(W_,60) = DYNX(DP_,28);
DYNX(W_,107) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1]}, {gearbox.lossyGear.lossTable[1, 2]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(W_,56), 1, 1), 
  RealTemporaryDense( &DYNX(W_,57), 1, 1), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,108) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1]}, {gearbox.lossyGear.lossTable[1, 3]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(W_,56), 1, 1), 
  RealTemporaryDense( &DYNX(W_,58), 1, 1), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,109) = fabs((PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1]}, {gearbox.lossyGear.lossTable[1, 4]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(W_,56), 1, 1), 
  RealTemporaryDense( &DYNX(W_,59), 1, 1), 0, 1).yi0_0_0member));
PopAllMarks();
DYNX(W_,110) = fabs((PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1]}, {gearbox.lossyGear.lossTable[1, 5]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(W_,56), 1, 1), 
  RealTemporaryDense( &DYNX(W_,60), 1, 1), 0, 1).yi0_0_0member));
PopAllMarks();
DYNX(DYNhelp,3) = fabs(DYNX(W_,107)-1.0);
DYNX(DYNhelp,4) = fabs(DYNX(W_,108)-1.0);
DYNX(W_,111) = IF DYNX(DYNhelp,3) <= 1E-15 AND DYNX(DYNhelp,4) <= 1E-15 THEN 
  DYNX(W_,109)/(double)(2) ELSE divGuarded(DYNX(W_,109)-DYNX(W_,110),
  "gearbox.lossyGear.tau_bf1_0-gearbox.lossyGear.tau_bf2_0",DYNX(W_,107)-
  divinvGuarded(DYNX(W_,108),"gearbox.lossyGear.eta_mf2_0"),"gearbox.lossyGear.eta_mf1_0-1.0/gearbox.lossyGear.eta_mf2_0");
DYNX(W_,112) = DYNX(DP_,29);
DYNX(W_,113) = DYNX(DP_,30);
DYNX(W_,114) = DYNX(DP_,31);
DYNX(W_,121) = DYNX(W_,114)/(double)(2);
DYNX(W_,122) =  -DYNX(W_,121);
BoundParameterConstantSection
DYNX(W_,96) = (PushModelContext(1,"Modelica.Math.Matrices.isEqual(gearbox.lossyGear.lossTable, [0, 1, 1, 0, 0], 1E-15)")
  Modelica_Math_Matrices_isEqual(RealTemporaryDense( &DYNX(W_,56), 2, 1, 5), 
  RealTemporaryDense( DymArrays1, 2, 1, 5), 1E-15));
PopAllMarks();
DYNX(W_,5) = DYNX(DP_,0)*(1+DYNX(DP_,2)*(DYNX(W_,3)-DYNX(DP_,1)));
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,92) = true;
DYNX(W_,93) = false;
DYNX(W_,94) = false;
DYNX(W_,95) = false;
DYNX(W_,102) = 2;
DYNX(F_,4) = 0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
DYNX(X_,1) = DYNX(W_,29);
DYNX(X_,2) = DYNX(W_,35);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,102);
InitialSection
InitialSection2
DYNX(W_,7) = 0.0;
DYNX(X_,1) = DYNX(W_,29);
DYNX(X_,2) = DYNX(W_,35);
InitialSection
InitialSection2
DYNX(W_,102) = DYNX(Aux_,0);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,123) = IF initial() THEN (IF Greater(DYNX(X_,3),"gearbox.phi_rel", 1.5*
  DYNX(W_,121),"1.5*gearbox.elastoBacklash.bMax", 0) THEN DYNX(W_,112)*(
  DYNX(X_,3)-DYNX(W_,121)) ELSE IF Less(DYNX(X_,3),"gearbox.phi_rel", 1.5*
  DYNX(W_,122),"1.5*gearbox.elastoBacklash.bMin", 1) THEN DYNX(W_,112)*(
  DYNX(X_,3)-DYNX(W_,122)) ELSE 0.3333333333333333*DYNX(W_,112)*DYNX(X_,3))
   ELSE IF fabs(DYNX(W_,114)) <= 1E-10 THEN DYNX(W_,112)*DYNX(X_,3) ELSE IF 
  Greater(DYNX(X_,3),"gearbox.phi_rel", DYNX(W_,121),"gearbox.elastoBacklash.bMax",
   2) THEN DYNX(W_,112)*(DYNX(X_,3)-DYNX(W_,121)) ELSE IF Less(DYNX(X_,3),
  "gearbox.phi_rel", DYNX(W_,122),"gearbox.elastoBacklash.bMin", 3) THEN 
  DYNX(W_,112)*(DYNX(X_,3)-DYNX(W_,122)) ELSE 0;
DYNX(W_,124) = DYNX(W_,113)*DYNX(X_,4);
DYNX(W_,42) = IF initial() THEN DYNX(W_,123)+DYNX(W_,124) ELSE IF fabs(
  DYNX(W_,114)) <= 1E-10 THEN DYNX(W_,123)+DYNX(W_,124) ELSE IF Greater(
  DYNX(X_,3),"gearbox.phi_rel", DYNX(W_,121),"gearbox.elastoBacklash.bMax", 2)
   THEN (IF DYNX(W_,123)+DYNX(W_,124) <= 0 THEN 0 ELSE DYNX(W_,123)+RealBmin(
  DYNX(W_,123), DYNX(W_,124))) ELSE IF Less(DYNX(X_,3),"gearbox.phi_rel", 
  DYNX(W_,122),"gearbox.elastoBacklash.bMin", 3) THEN (IF DYNX(W_,123)+
  DYNX(W_,124) >= 0 THEN 0 ELSE DYNX(W_,123)+RealBmax(DYNX(W_,123), DYNX(W_,124)))
   ELSE 0;
 /* Linear system of equations to solve. */
DYNX(F_,6) = RememberSimple_(DYNX(F_,6), 0);
SolveScalarLinearParametric(DYNX(DP_,32),"inertia.J",  -DYNX(W_,42),
  " -gearbox.flange_b.tau", DYNX(F_,6),"der(inertia.w)");
 /* End of Equation Block */ 

DYNX(W_,40) = DYNX(DP_,20)+(IF LessTime(DYNX(DP_,21), 0) THEN 0 ELSE 
  DYNX(DP_,19));
DYNX(W_,21) = DYNX(W_,40)-DYNX(X_,5);
DYNX(F_,1) = DYNX(W_,25)*DYNX(W_,21);
DYNX(W_,0) = DYNX(W_,5)*DYNX(X_,0);
DYNX(W_,24) = DYNX(DP_,14)*DYNX(W_,21);
DYNX(W_,36) = IF DYNX(W_,37) THEN 0 ELSE divGuarded(DYNX(W_,32)*(DYNX(W_,21)-
  DYNX(X_,2)),"PID.D.k*(PID.u-PID.D.x)",DYNX(W_,33),"PID.D.T");
DYNX(W_,39) = DYNX(DP_,16)*DYNX(W_,24)+DYNX(DP_,17)*DYNX(X_,1)+DYNX(DP_,18)*
  DYNX(W_,36);
DYNX(W_,19) = DYNX(W_,38)*DYNX(W_,39);
DYNX(W_,1) = DYNX(W_,19)-DYNX(W_,0);
DYNX(W_,66) = DYNX(X_,6)-DYNX(X_,4);
DYNX(W_,17) = DYNX(W_,55)*DYNX(W_,66);
DYNX(W_,9) = DYNX(DP_,4)*DYNX(W_,17);
DYNX(W_,8) = DYNX(W_,1)-DYNX(W_,9);
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 1);
SolveScalarLinearParametric(DYNX(DP_,3),"electricalMotor.La.L", DYNX(W_,8),
  "electricalMotor.La.v", DYNX(F_,0),"der(electricalMotor.La.i)");
 /* End of Equation Block */ 

DYNX(F_,5) = DYNX(X_,6);
DYNX(F_,2) = IF DYNX(W_,37) THEN 0 ELSE divGuarded(DYNX(W_,21)-DYNX(X_,2),
  "PID.u-PID.D.x",DYNX(W_,33),"PID.D.T");
DYNX(F_,3) = DYNX(X_,4);
DYNX(W_,69) = IF DYNX(W_,96) THEN 1 ELSE (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1]}, {gearbox.lossyGear.lossTable[1, 2]}, noEvent(abs(electricalMotor.inertia.w)), 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(W_,56), 1, 1), 
  RealTemporaryDense( &DYNX(W_,57), 1, 1), fabs(DYNX(W_,17)), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,73) = IF DYNX(W_,96) THEN 1 ELSE DYNX(W_,69);
DYNX(W_,70) = IF DYNX(W_,96) THEN 1 ELSE (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1]}, {gearbox.lossyGear.lossTable[1, 3]}, noEvent(abs(electricalMotor.inertia.w)), 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(W_,56), 1, 1), 
  RealTemporaryDense( &DYNX(W_,58), 1, 1), fabs(DYNX(W_,17)), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,74) = IF DYNX(W_,96) THEN 1 ELSE DYNX(W_,70);
DYNX(W_,71) = IF DYNX(W_,96) THEN 0 ELSE (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1]}, {gearbox.lossyGear.lossTable[1, 4]}, noEvent(abs(electricalMotor.inertia.w)), 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(W_,56), 1, 1), 
  RealTemporaryDense( &DYNX(W_,59), 1, 1), fabs(DYNX(W_,17)), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,77) = IF DYNX(W_,96) THEN 0 ELSE fabs(DYNX(W_,71));
DYNX(W_,72) = IF DYNX(W_,96) THEN 0 ELSE (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1]}, {gearbox.lossyGear.lossTable[1, 5]}, noEvent(abs(electricalMotor.inertia.w)), 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(W_,56), 1, 1), 
  RealTemporaryDense( &DYNX(W_,60), 1, 1), fabs(DYNX(W_,17)), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,78) = IF DYNX(W_,96) THEN 0 ELSE fabs(DYNX(W_,72));
DYNX(DYNhelp,5) = fabs(DYNX(W_,73)-1.0);
DYNX(DYNhelp,6) = fabs(DYNX(W_,74)-1.0);
DYNX(W_,75) = IF DYNX(DYNhelp,5) <= 1E-15 AND DYNX(DYNhelp,6) <= 1E-15 THEN 
  DYNX(W_,77)/(double)(2) ELSE divGuarded(DYNX(W_,77)-DYNX(W_,78),
  "gearbox.lossyGear.tau_bf1-gearbox.lossyGear.tau_bf2",DYNX(W_,73)-
  divinvGuarded(DYNX(W_,74),"gearbox.lossyGear.eta_mf2"),"gearbox.lossyGear.eta_mf1-1.0/gearbox.lossyGear.eta_mf2");
DYNX(W_,12) =  -DYNX(DP_,4)*DYNX(X_,0);

MixedSystemOfEquations(19, DYNX(DYNhelp,7))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[1] */
  /* Introducing 16 common subexpressions used in 18 expressions */
  /* Of the common subexpressions 16 are reals, 0 are integers, and 0
     are booleans. */
  DYNX(DYNhelp,26) = IF DYNX(W_,92) THEN 1.0 ELSE 0.0;
  DYNX(DYNhelp,27) = IF DYNX(W_,96) THEN 0.0 ELSE IF DYNX(W_,95) THEN 0.0 ELSE 
    IF DYNX(W_,93) OR PRE(DYNX(W_,102), 0) == 1 THEN 1.0 ELSE 0.0;
  DYNX(DYNhelp,28) = DYNX(DYNhelp,26)*DYNX(DYNhelp,27);
  DYNX(DYNhelp,29) = IF DYNX(W_,96) THEN 0.0 ELSE IF DYNX(W_,95) THEN 0.0 ELSE 
    IF DYNX(W_,93) OR PRE(DYNX(W_,102), 0) == 1 THEN 0.0 ELSE 1.0;
  DYNX(DYNhelp,30) = DYNX(DYNhelp,26)*DYNX(DYNhelp,29);
  DYNX(DYNhelp,31) = divinvGuarded(DYNX(W_,74),"gearbox.lossyGear.eta_mf2");
  DYNX(DYNhelp,32) = IF DYNX(W_,92) THEN 0.0 ELSE 1.0;
  DYNX(DYNhelp,33) = DYNX(DYNhelp,32)*DYNX(DYNhelp,29);
  DYNX(DYNhelp,34) = DYNX(DYNhelp,32)*DYNX(DYNhelp,27);
  DYNX(DYNhelp,35) = (DYNX(DYNhelp,31)-1)*DYNX(DYNhelp,30)+(DYNX(W_,73)-1)*
    DYNX(DYNhelp,33)+(DYNX(DYNhelp,31)-1.0)*DYNX(DYNhelp,34)+(DYNX(W_,73)-1.0)*
    DYNX(DYNhelp,28);
  /* Automatic tearing of linear system of 10 simultaneous equations
  gave a linear system of 2 equations for numerical solution.*/
  {
    const char*const varnames_[]={"gearbox.lossyGear.sa", "gearbox.lossyGear.tauLoss"};
    const double nominal_[]={1, 1};
    DidLinearSystemOfEquations(J, b, y, 2, DYNX(DYNhelp,36), 24, 
      DYNX(did_->helpvari_vec,0), 8);
    /* Jacobian depending on continuous variables */
    SetNeedFactor(J);
    if (NeedFactor(J)) {
      MatrixZeros(J);
      DYNX(DYNhelp,60) = DYNX(DP_,6)*DYNX(DYNhelp,35);
      DYNX(DYNhelp,61) = IF DYNX(W_,95) THEN 0.0 ELSE 1.0;
      DYNX(DYNhelp,62) = IF DYNX(W_,95) THEN 0.0 ELSE -1.0;
      DYNX(DYNhelp,63) = DYNX(DP_,6)*DYNX(W_,55);
      SetMatrixLeading(J, 1, 1, 2,  -((IF DYNX(W_,96) THEN 0.0 ELSE IF 
        DYNX(W_,95) THEN 1.0 ELSE 0.0)+DYNX(DYNhelp,60)*DYNX(DYNhelp,61)));
      SetMatrixLeading(J, 1, 2, 2, 1.0-DYNX(DYNhelp,60)*DYNX(DYNhelp,62));
      SetMatrixLeading(J, 2, 1, 2, DYNX(DYNhelp,63)*DYNX(DYNhelp,61));
      SetMatrixLeading(J, 2, 2, 2, DYNX(W_,55)+DYNX(DYNhelp,63)*DYNX(DYNhelp,62));
    }
    SetVector(b, 1, DYNX(DYNhelp,28)*DYNX(W_,77)-(DYNX(DYNhelp,30)*DYNX(W_,78)-
      DYNX(DYNhelp,35)*DYNX(W_,12)+DYNX(DYNhelp,33)*DYNX(W_,77))+
      DYNX(DYNhelp,34)*DYNX(W_,78));
    SetVector(b, 2, DYNX(W_,42)-DYNX(W_,55)*DYNX(W_,12));
    SetVector(y, 1, RememberSimple_(DYNX(W_,68), 2));
    SetVector(y, 2, RememberSimple_(DYNX(W_,87), 3));
    SolveLinearSystemOfEquationsMixed(J, b, y, 1);
    DYNX(W_,68) = GetVector(y, 1);
    DYNX(W_,87) = GetVector(y, 2);
    EndStaticLinearSystemOfEquations(J);
  }
  DYNX(W_,18) = IF DYNX(W_,95) THEN 0 ELSE DYNX(W_,68)-DYNX(W_,87);
  DYNX(W_,20) = DYNX(DP_,6)*DYNX(W_,18)+DYNX(W_,12);
  DYNX(DYNhelp,64) = (1-DYNX(DYNhelp,31))*DYNX(W_,20);
  DYNX(W_,82) =  -(DYNX(DYNhelp,64)+DYNX(W_,78));
  DYNX(DYNhelp,65) = (1-DYNX(W_,73))*DYNX(W_,20);
  DYNX(W_,81) =  -(DYNX(DYNhelp,65)+DYNX(W_,77));
  DYNX(W_,89) = IF DYNX(W_,92) THEN DYNX(W_,82) ELSE DYNX(W_,81);
  DYNX(W_,80) = DYNX(W_,78)-DYNX(DYNhelp,64);
  DYNX(W_,79) = DYNX(W_,77)-DYNX(DYNhelp,65);
  DYNX(W_,88) = IF DYNX(W_,92) THEN DYNX(W_,79) ELSE DYNX(W_,80);
   /* End of Equation Block */ 

  DYNX(W_,76) = IF DYNX(W_,96) THEN  -DYNX(W_,20) ELSE IF DYNX(W_,95) THEN  -
    DYNX(W_,20) ELSE IF DYNX(W_,93) OR PRE(DYNX(W_,102), 0) == 1 THEN  -(
    DYNX(W_,20)+DYNX(W_,75)) ELSE DYNX(W_,75)-DYNX(W_,20);
  DYNX(W_,85) =  -((1-DYNX(W_,107))*DYNX(W_,20)+DYNX(W_,109));
  if (NewParameters_) {
  DYNX(DYNhelp,66) = divinvGuarded(DYNX(W_,108),"gearbox.lossyGear.eta_mf2_0");
  }
  DYNX(W_,86) =  -((1-DYNX(DYNhelp,66))*DYNX(W_,20)+DYNX(W_,110));
  DYNX(W_,104) = DYNX(W_,111)-DYNX(W_,20);
  DYNX(W_,91) = IF DYNX(W_,104) > 0 THEN DYNX(W_,86) ELSE DYNX(W_,85);
  DYNX(W_,84) = DYNX(W_,110)-(1-DYNX(DYNhelp,66))*DYNX(W_,20);
  DYNX(W_,83) = DYNX(W_,109)-(1-DYNX(W_,107))*DYNX(W_,20);
  DYNX(W_,103) =  -(DYNX(W_,20)+DYNX(W_,111));
  DYNX(W_,90) = IF DYNX(W_,103) > 0 THEN DYNX(W_,83) ELSE DYNX(W_,84);

  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,92),"gearbox.lossyGear.tau_aPos", GreaterEqual(
    DYNX(W_,76),"gearbox.lossyGear.tau_eta", 0,"0", 4));
  UpdateVariableNamed(DYNX(W_,94),"gearbox.lossyGear.startBackward", PRE(
    DYNX(W_,102), 0) == 0 AND Less(DYNX(W_,68),"gearbox.lossyGear.sa", 
    DYNX(W_,91),"gearbox.lossyGear.tauLossMin_m", 5) OR initial() AND Less(
    DYNX(W_,17),"electricalMotor.inertia.w", 0,"0", 6));
  UpdateVariableNamed(DYNX(W_,93),"gearbox.lossyGear.startForward", PRE(
    DYNX(W_,102), 0) == 0 AND Greater(DYNX(W_,68),"gearbox.lossyGear.sa", 
    DYNX(W_,90),"gearbox.lossyGear.tauLossMax_p", 7) OR initial() AND Greater(
    DYNX(W_,17),"electricalMotor.inertia.w", 0,"0", 8));
  UpdateVariableNamed(DYNX(W_,95),"gearbox.lossyGear.locked",  NOT (DYNX(W_,96)
     OR PRE(DYNX(W_,102), 0) == 1 OR DYNX(W_,93) OR PRE(DYNX(W_,102), 0) == -1
     OR DYNX(W_,94)));
  MixedModeInit(5, DYNX(DYNhelp,67))
  ThetaMixedCross(0,4)
  ThetaMixedCross(1,5)
  ThetaMixedCross(2,6)
  ThetaMixedCross(3,7)
  ThetaMixedCross(4,8)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,81), 1)
  UpdateReal(DYNX(W_,82), 2)
  UpdateReal(DYNX(W_,89), 3)
  UpdateReal(DYNX(W_,80), 4)
  UpdateReal(DYNX(W_,79), 5)
  UpdateReal(DYNX(W_,76), 6)
  UpdateReal(DYNX(W_,88), 7)
  UpdateReal(DYNX(W_,85), 8)
  UpdateReal(DYNX(W_,86), 9)
  UpdateReal(DYNX(W_,104), 10)
  UpdateReal(DYNX(W_,91), 11)
  UpdateReal(DYNX(W_,84), 12)
  UpdateReal(DYNX(W_,83), 13)
  UpdateReal(DYNX(W_,103), 14)
  UpdateReal(DYNX(W_,90), 15)
  UpdateReal(DYNX(W_,68), 16)
  UpdateReal(DYNX(W_,87), 17)
  UpdateReal(DYNX(W_,20), 18)
  UpdateReal(DYNX(W_,18), 19)
EndMixedSystemOfEquations

 /* Linear system of equations to solve. */
DYNX(W_,67) = RememberSimple_(DYNX(W_,67), 4);
SolveScalarLinearParametric( -DYNX(W_,55)," -gearbox.lossyGear.ratio",  -
  DYNX(W_,18)," -der(electricalMotor.inertia.w)", DYNX(W_,67),"der(gearbox.lossyGear.phi_b, 2)");
 /* End of Equation Block */ 

DYNX(F_,4) = DYNX(F_,6)-DYNX(W_,67);

AcceptedSection1
DYNX(W_,102) = IF DYNX(W_,96) THEN 2 ELSE IF (PRE(DYNX(W_,102), 0) == 1 OR 
  DYNX(W_,93)) AND Greater(DYNX(W_,17),"electricalMotor.inertia.w", 0,"0", 8)
   THEN 1 ELSE IF (PRE(DYNX(W_,102), 0) == -1 OR DYNX(W_,94)) AND Less(
  DYNX(W_,17),"electricalMotor.inertia.w", 0,"0", 6) THEN -1 ELSE 0;

AcceptedSection2
DYNX(W_,65) =  -(DYNX(X_,3)-DYNX(X_,5)+DYNX(DP_,22));
DYNX(W_,64) = DYNX(W_,55)*DYNX(W_,65);
DYNX(W_,16) = DYNX(W_,64)+DYNX(DP_,22);
DYNX(W_,11) = DYNX(W_,16)-DYNX(DP_,5);
DYNX(W_,54) = DYNX(W_,65)+DYNX(DP_,22);
DYNX(W_,4) = DYNX(W_,0)*DYNX(X_,0);
DYNX(W_,44) = DYNX(W_,42)-DYNX(W_,20);
DYNX(W_,120) = IF initial() THEN DYNX(W_,124)*DYNX(X_,4) ELSE IF fabs(
  DYNX(W_,114)) <= 1E-10 THEN DYNX(W_,124)*DYNX(X_,4) ELSE IF Greater(DYNX(X_,3),
  "gearbox.phi_rel", DYNX(W_,121),"gearbox.elastoBacklash.bMax", 2) THEN (IF 
  DYNX(W_,123)+DYNX(W_,124) <= 0 THEN 0 ELSE RealBmin(DYNX(W_,123), DYNX(W_,124))
  *DYNX(X_,4)) ELSE IF Less(DYNX(X_,3),"gearbox.phi_rel", DYNX(W_,122),
  "gearbox.elastoBacklash.bMin", 3) THEN (IF DYNX(W_,123)+DYNX(W_,124) >= 0
   THEN 0 ELSE RealBmax(DYNX(W_,123), DYNX(W_,124))*DYNX(X_,4)) ELSE 0;
DYNX(W_,63) = DYNX(W_,87)*DYNX(W_,17);
DYNX(W_,50) = DYNX(W_,120)+DYNX(W_,63);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("electricalMotor.Ra.R", "Resistance at temperature T_ref [Ohm]",\
 0, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("electricalMotor.Ra.T_ref", "Reference temperature [K|degC]", 1,\
 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("electricalMotor.Ra.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 2, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("electricalMotor.Ra.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("electricalMotor.Ra.i", "Current flowing from pin p to pin n [A]",\
 "electricalMotor.La.i", 1, 1, 0, 0)
DeclareAlias2("electricalMotor.Ra.p.v", "Potential at the pin [V]", \
"electricalMotor.u", 1, 5, 19, 4)
DeclareAlias2("electricalMotor.Ra.p.i", "Current flowing into the pin [A]", \
"electricalMotor.La.i", 1, 1, 0, 132)
DeclareVariable("electricalMotor.Ra.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("electricalMotor.Ra.n.i", "Current flowing into the pin [A]", \
"electricalMotor.La.i", -1, 1, 0, 132)
DeclareVariable("electricalMotor.Ra.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("electricalMotor.Ra.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("electricalMotor.Ra.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("electricalMotor.Ra.T_heatPort", "Temperature of heatPort [K|degC]",\
 "electricalMotor.Ra.T", 1, 5, 3, 0)
DeclareVariable("electricalMotor.Ra.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("electricalMotor.ground.p.v", "Potential at the pin [V]", 0, \
0.0,0.0,0.0,0,521)
DeclareVariable("electricalMotor.ground.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("electricalMotor.La.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("electricalMotor.La.i", "Current flowing from pin p to pin n [A]", 0,\
 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("electricalMotor.La.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("electricalMotor.La.p.v", "Potential at the pin [V]", \
"electricalMotor.Ra.n.v", 1, 5, 1, 4)
DeclareAlias2("electricalMotor.La.p.i", "Current flowing into the pin [A]", \
"electricalMotor.La.i", 1, 1, 0, 132)
DeclareVariable("electricalMotor.La.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("electricalMotor.La.n.i", "Current flowing into the pin [A]", \
"electricalMotor.La.i", -1, 1, 0, 132)
DeclareParameter("electricalMotor.La.L", "Inductance [H]", 3, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("electricalMotor.emf.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("electricalMotor.emf.k", "Transformation coefficient [N.m/A]", 4,\
 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("electricalMotor.emf.v", "Voltage drop between the two pins [V]", \
"electricalMotor.La.n.v", 1, 5, 9, 0)
DeclareAlias2("electricalMotor.emf.i", "Current flowing from positive to negative pin [A]",\
 "electricalMotor.La.i", 1, 1, 0, 0)
DeclareVariable("electricalMotor.emf.phi", "Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("electricalMotor.emf.der(phi)", "der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "electricalMotor.inertia.w", 1, 5, 17, 0)
DeclareAlias2("electricalMotor.emf.w", "Angular velocity of flange relative to support [rad/s]",\
 "electricalMotor.inertia.w", 1, 5, 17, 0)
DeclareVariable("electricalMotor.emf.tau", "Torque of flange [N.m]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("electricalMotor.emf.tauElectrical", "Electrical torque [N.m]", \
"electricalMotor.emf.tau", -1, 5, 12, 0)
DeclareAlias2("electricalMotor.emf.p.v", "Potential at the pin [V]", \
"electricalMotor.La.n.v", 1, 5, 9, 4)
DeclareAlias2("electricalMotor.emf.p.i", "Current flowing into the pin [A]", \
"electricalMotor.La.i", 1, 1, 0, 132)
DeclareVariable("electricalMotor.emf.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("electricalMotor.emf.n.i", "Current flowing into the pin [A]", \
"electricalMotor.La.i", -1, 1, 0, 132)
DeclareAlias2("electricalMotor.emf.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "electricalMotor.inertia.phi", 1, 5, 16, 4)
DeclareAlias2("electricalMotor.emf.flange.tau", "Cut torque in the flange [N.m]",\
 "electricalMotor.emf.tau", 1, 5, 12, 132)
DeclareParameter("electricalMotor.emf.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 5, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("electricalMotor.emf.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "electricalMotor.emf.fixed.phi0", 1, 7, 5, 1028)
DeclareAlias2("electricalMotor.emf.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 "electricalMotor.emf.tau", 1, 5, 12, 1156)
DeclareAlias2("electricalMotor.emf.internalSupport.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "electricalMotor.emf.tau", -1, 5, 12, 1024)
DeclareAlias2("electricalMotor.emf.internalSupport.phi", "External support angle (= flange.phi) [rad|deg]",\
 "electricalMotor.emf.fixed.phi0", 1, 7, 5, 1024)
DeclareAlias2("electricalMotor.emf.internalSupport.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "electricalMotor.emf.fixed.phi0", 1, 7, 5, 1028)
DeclareAlias2("electricalMotor.emf.internalSupport.flange.tau", "Cut torque in the flange [N.m]",\
 "electricalMotor.emf.tau", -1, 5, 12, 1156)
DeclareAlias2("electricalMotor.signalVoltage.p.v", "Potential at the pin [V]", \
"electricalMotor.u", 1, 5, 19, 4)
DeclareAlias2("electricalMotor.signalVoltage.p.i", "Current flowing into the pin [A]",\
 "electricalMotor.La.i", -1, 1, 0, 132)
DeclareVariable("electricalMotor.signalVoltage.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("electricalMotor.signalVoltage.n.i", "Current flowing into the pin [A]",\
 "electricalMotor.La.i", 1, 1, 0, 132)
DeclareAlias2("electricalMotor.signalVoltage.v", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "electricalMotor.u", 1, 5, 19, 0)
DeclareAlias2("electricalMotor.signalVoltage.i", "Current flowing from pin p to pin n [A]",\
 "electricalMotor.La.i", -1, 1, 0, 0)
DeclareAlias2("electricalMotor.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "electricalMotor.inertia.phi", 1, 5, 16, 4)
DeclareAlias2("electricalMotor.inertia.flange_a.tau", "Cut torque in the flange [N.m]",\
 "electricalMotor.emf.tau", -1, 5, 12, 132)
DeclareAlias2("electricalMotor.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "electricalMotor.inertia.phi", 1, 5, 16, 4)
DeclareAlias2("electricalMotor.inertia.flange_b.tau", "Cut torque in the flange [N.m]",\
 "electricalMotor.y.tau", 1, 5, 20, 132)
DeclareParameter("electricalMotor.inertia.J", "Moment of inertia [kg.m2]", 6, 1,\
 0.0,1E+100,0.0,0,560)
DeclareVariable("electricalMotor.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("electricalMotor.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("electricalMotor.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "electricalMotor.inertia.w", 1, 5, 17, 0)
DeclareVariable("electricalMotor.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("electricalMotor.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("electricalMotor.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "electricalMotor.inertia.der(w)", 1, 5, 18, 0)
DeclareVariable("electricalMotor.u", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("electricalMotor.y.phi", "Absolute rotation angle of flange [rad|deg]",\
 "electricalMotor.inertia.phi", 1, 5, 16, 4)
DeclareVariable("electricalMotor.y.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("PID.u", "Connector of Real input signal [rad]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("PID.y", "Connector of Real output signal [V]", "electricalMotor.u", 1,\
 5, 19, 0)
DeclareParameter("PID.k", "Gain [1]", 7, 7.5, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.Ti", "Time Constant of Integrator [s]", 8, 25, 1E-60,\
1E+100,0.0,0,560)
DeclareParameter("PID.Td", "Time Constant of Derivative block [s]", 9, 0.01, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("PID.Nd", "The higher Nd, the more ideal the derivative block",\
 10, 10, 1E-60,1E+100,0.0,0,560)
DeclareVariable("PID.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.InitPID)]",\
 5, 1.0,5.0,0.0,0,517)
DeclareParameter("PID.xi_start", "Initial or guess value for integrator output (= integrator state) [s.rad]",\
 11, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.xd_start", "Initial or guess value for state of derivative block [rad]",\
 12, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.y_start", "Initial value of output [V]", 13, 0, 0.0,0.0,\
0.0,0,560)
DeclareVariable("PID.unitTime", "[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareParameter("PID.P.k", "Gain value multiplied with input signal [1]", 14, 1,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("PID.P.u", "Input signal connector [rad]", "PID.u", 1, 5, 21, 0)
DeclareVariable("PID.P.y", "Output signal connector [rad]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PID.I.k", "Integrator gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PID.I.use_reset", "=true, if reset port enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("PID.I.use_set", "=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("PID.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("PID.I.y_start", "Initial or guess value of output (= state) [s.rad]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("PID.I.u", "Connector of Real input signal [rad]", "PID.u", 1, 5, 21,\
 0)
DeclareState("PID.I.y", "Connector of Real output signal [s.rad]", 1, 0.0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("PID.I.der(y)", "der(Connector of Real output signal) [rad]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PID.I.local_reset", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("PID.I.local_set", "", 0, 0.0,0.0,0.0,0,1537)
DeclareVariable("PID.D.k", "Gains [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PID.D.T", "Time constants (T>0 required; T=0 is ideal derivative block) [s]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("PID.D.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("PID.D.x_start", "Initial or guess value of state [rad]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("PID.D.y_start", "Initial value of output (= state) [rad/s]", 15,\
 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("PID.D.u", "Connector of Real input signal [rad]", "PID.u", 1, 5, 21,\
 0)
DeclareVariable("PID.D.y", "Connector of Real output signal [rad/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareState("PID.D.x", "State of block [rad]", 2, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("PID.D.der(x)", "der(State of block) [rad/s]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("PID.D.zeroGain", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2563)
DeclareVariable("PID.Gain.k", "Gain value multiplied with input signal [1]", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("PID.Gain.u", "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("PID.Gain.y", "Output signal connector [V]", "electricalMotor.u", 1,\
 5, 19, 0)
DeclareParameter("PID.Add.k1", "Gain of input signal 1", 16, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.Add.k2", "Gain of input signal 2", 17, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.Add.k3", "Gain of input signal 3", 18, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PID.Add.u1", "Connector of Real input signal 1 [rad]", "PID.P.y", 1,\
 5, 24, 0)
DeclareAlias2("PID.Add.u2", "Connector of Real input signal 2 [s.rad]", \
"PID.I.y", 1, 1, 1, 0)
DeclareAlias2("PID.Add.u3", "Connector of Real input signal 3 [rad/s]", \
"PID.D.y", 1, 5, 36, 0)
DeclareAlias2("PID.Add.y", "Connector of Real output signal", "PID.Gain.u", 1, 5,\
 39, 0)
DeclareParameter("step.height", "Height of step [rad]", 19, 3.14, 0.0,0.0,0.0,0,560)
DeclareVariable("step.y", "Connector of Real output signal [rad]", 0.0, 0.0,0.0,\
0.0,0,640)
DeclareParameter("step.offset", "Offset of output signal y [rad]", 20, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("step.startTime", "Output y = offset for time < startTime [s]",\
 21, 50, 0.0,0.0,0.0,0,560)
DeclareVariable("gearbox.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("gearbox.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "electricalMotor.inertia.phi", 1, 5, 16, 4)
DeclareAlias2("gearbox.flange_a.tau", "Cut torque in the flange [N.m]", \
"electricalMotor.y.tau", -1, 5, 20, 132)
DeclareAlias2("gearbox.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 5, 4)
DeclareVariable("gearbox.flange_b.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("gearbox.internalSupport.phi", "Absolute rotation angle of flange [rad|deg]",\
 "gearbox.fixed.phi0", 1, 7, 22, 1028)
DeclareVariable("gearbox.internalSupport.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareParameter("gearbox.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 22, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("gearbox.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "gearbox.fixed.phi0", 1, 7, 22, 1028)
DeclareVariable("gearbox.fixed.flange.tau", "Cut torque in the flange [N.m]", \
0.0, 0.0,0.0,0.0,0,2824)
DeclareParameter("gearbox.ratio", "Transmission ratio (flange_a.phi/flange_b.phi) [1]",\
 23, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[1, 1]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 24, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[1, 2]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 25, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[1, 3]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 26, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[1, 4]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 27, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[1, 5]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 28, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.c", "Gear elasticity (spring constant) [N.m/rad]", 29,\
 100000.0, 1E-60,1E+100,0.0,0,560)
DeclareParameter("gearbox.d", "(relative) gear damping [N.m.s/rad]", 30, 0, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("gearbox.b", "Total backlash [rad|deg]", 31, 0, 0.0,1E+100,0.0,\
0,560)
DeclareVariable("gearbox.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 4, 1.0,5.0,0.0,0,1541)
DeclareVariable("gearbox.useHeatPort", "=true, if HeatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("gearbox.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("gearbox.fixedTemperature.T", "Fixed temperature at port [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("gearbox.fixedTemperature.port.T", "Port temperature [K|degC]", \
293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("gearbox.fixedTemperature.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("gearbox.internalHeatPort.T", "Port temperature [K|degC]", \
293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("gearbox.internalHeatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareState("gearbox.phi_rel", "Relative rotation angle over gear elasticity (= flange_b.phi - lossyGear.flange_b.phi) [rad|deg]",\
 3, 0, 0.0,0.0,0.0001,0,560)
DeclareDerivative("gearbox.der(phi_rel)", "der(Relative rotation angle over gear elasticity (= flange_b.phi - lossyGear.flange_b.phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("gearbox.w_rel", "Relative angular velocity over gear elasticity (= der(phi_rel)) [rad/s]",\
 4, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("gearbox.der(w_rel)", "der(Relative angular velocity over gear elasticity (= der(phi_rel))) [rad/s2]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("gearbox.a_rel", "Relative angular acceleration over gear elasticity (= der(w_rel)) [rad/s2]",\
 "gearbox.der(w_rel)", 1, 6, 4, 0)
DeclareVariable("gearbox.lossyGear.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareAlias2("gearbox.lossyGear.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "electricalMotor.inertia.phi", 1, 5, 16, 4)
DeclareAlias2("gearbox.lossyGear.flange_a.tau", "Cut torque in the flange [N.m]",\
 "electricalMotor.y.tau", -1, 5, 20, 132)
DeclareVariable("gearbox.lossyGear.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("gearbox.lossyGear.flange_b.tau", "Cut torque in the flange [N.m]",\
 "gearbox.flange_b.tau", 1, 5, 42, 132)
DeclareAlias2("gearbox.lossyGear.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "gearbox.fixed.phi0", 1, 7, 22, 4)
DeclareAlias2("gearbox.lossyGear.support.tau", "Cut torque in the flange [N.m]",\
 "gearbox.fixed.flange.tau", -1, 5, 44, 132)
DeclareAlias2("gearbox.lossyGear.phi_support", "Absolute angle of support flange [rad|deg]",\
 "gearbox.fixed.phi0", 1, 7, 22, 1024)
DeclareVariable("gearbox.lossyGear.ratio", "Transmission ratio (flange_a.phi/flange_b.phi) [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[1, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[1, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[1, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[1, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[1, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("gearbox.lossyGear.heatPort.T", "Port temperature [K|degC]", \
293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("gearbox.lossyGear.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "gearbox.lossyGear.lossPower", -1, 5, 63, 132)
DeclareVariable("gearbox.lossyGear.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.phi_a", "Angle between left shaft flange and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("gearbox.lossyGear.der(phi_a)", "der(Angle between left shaft flange and support) [rad/s]",\
 "electricalMotor.inertia.w", 1, 5, 17, 0)
DeclareVariable("gearbox.lossyGear.phi_b", "Angle between right shaft flange and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.der(phi_b)", "der(Angle between right shaft flange and support) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.der(phi_b, 2)", "der(Angle between right shaft flange and support2) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.sa", "Path parameter for acceleration and torque loss [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("gearbox.lossyGear.w_a", "Angular velocity of flange_a with respect to support [rad/s]",\
 "electricalMotor.inertia.w", 1, 5, 17, 0)
DeclareAlias2("gearbox.lossyGear.der(w_a)", "der(Angular velocity of flange_a with respect to support) [rad/s2]",\
 "electricalMotor.inertia.der(w)", 1, 5, 18, 0)
DeclareAlias2("gearbox.lossyGear.a_a", "Angular acceleration of flange_a with respect to support [rad/s2]",\
 "electricalMotor.inertia.der(w)", 1, 5, 18, 0)
DeclareVariable("gearbox.lossyGear.interpolation_result[1, 1]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.interpolation_result[1, 2]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.interpolation_result[1, 3]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.interpolation_result[1, 4]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.eta_mf1", "Mesh efficiency in case that flange_a is driving [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.eta_mf2", "Mesh efficiency in case that flange_b is driving [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tau_bf_a", "Bearing friction torque on flange_a side [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tau_eta", "Torque that determines the driving side (= if forwardSliding then flange_a.tau-tau_bf_a else if backwardSliding then flange_a.tau+tau_bf_a else flange_a.tau) [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tau_bf1", "Absolute resultant bearing friction torque with respect to flange_a in case that flange_a is driving (= |tau_bf_a*eta_mf1 + tau_bf_b/i|) [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tau_bf2", "Absolute resultant bearing friction torque with respect to flange_a in case that flange_b is driving (= |tau_bf_a/eta_mf2 + tau_bf_b/i|) [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant1", "Torque loss if w_a > 0 and flange_a.tau >= 0 [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant2", "Torque loss if w_a > 0 and flange_a.tau < 0 [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant3", "Torque loss if w_a < 0 and flange_a.tau >= 0 [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant4", "Torque loss if w_a < 0 and flange_a.tau < 0 [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant1_p", "Torque loss at w_a = 0+ to determine driving side (flange_a.tau >= 0) [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant2_p", "Torque loss at w_a = 0+ to determine driving side (flange_a.tau < 0) [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant3_m", "Torque loss at w_a = 0- to determine driving side (flange_a.tau >=0) [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant4_m", "Torque loss at w_a = 0- to determine driving side (flange_a.tau < 0) [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tauLoss", "Torque loss due to friction in the gear teeth and in the bearings [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tauLossMax", "Torque loss for positive speed [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tauLossMin", "Torque loss for negative speed [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tauLossMax_p", "Torque loss for positive speed [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tauLossMin_m", "Torque loss for negative speed [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tau_aPos", "Only for backwards compatibility (was previously: true, if torque of flange_a is not negative) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,706)
DeclareAlias2("gearbox.lossyGear.tau_etaPos", "true, if torque tau_eta is not negative [:#(type=Boolean)]",\
 "gearbox.lossyGear.tau_aPos", 1, 5, 92, 65)
DeclareVariable("gearbox.lossyGear.startForward", "true, if starting to roll forward [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,706)
DeclareVariable("gearbox.lossyGear.startBackward", "true, if starting to roll backward [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,706)
DeclareVariable("gearbox.lossyGear.locked", "true, if gear is locked [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,706)
DeclareVariable("gearbox.lossyGear.ideal", "= true, if losses are neglected (that is lossTable = [0, 1, 1, 0, 0]) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("gearbox.lossyGear.Unknown", "Value of mode is not known [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("gearbox.lossyGear.Free", "Element is not active [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("gearbox.lossyGear.Forward", "w_a > 0 (forward rolling) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("gearbox.lossyGear.Stuck", "w_a = 0 (forward rolling, locked or backward rolling) [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("gearbox.lossyGear.Backward", "w_a < 0 (backward rolling) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareVariable("gearbox.lossyGear.mode", "Mode of friction element (unknown, not active, forward/backward rolling, stuck) [:#(type=Integer)]",\
 2, -1.0,3.0,0.0,0,660)
DeclareVariable("gearbox.lossyGear.tau_eta_p", "tau_eta assuming positive omega [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tau_eta_m", "tau_eta assuming negative omega [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.unitAngularAcceleration", "[rad/s2]", 1, \
0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.lossyGear.unitTorque", "[N.m]", 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.lossyGear.eta_mf1_0", "[1]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.lossyGear.eta_mf2_0", "[1]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.lossyGear.tau_bf1_0", "[N.m]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.lossyGear.tau_bf2_0", "[N.m]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.lossyGear.tau_bf_a_0", "[N.m]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.elastoBacklash.c", "Spring constant (c > 0 required) [N.m/rad]",\
 100000.0, 1E-60,1E+100,0.0,0,513)
DeclareVariable("gearbox.elastoBacklash.d", "Damping constant [N.m.s/rad]", 0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("gearbox.elastoBacklash.b", "Total backlash [rad|deg]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("gearbox.elastoBacklash.phi_rel0", "Unstretched spring angle [rad|deg]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("gearbox.elastoBacklash.phi_rel", "Relative rotation angle (= flange_b.phi - flange_a.phi) [rad|deg]",\
 "gearbox.phi_rel", 1, 1, 3, 0)
DeclareAlias2("gearbox.elastoBacklash.der(phi_rel)", "der(Relative rotation angle (= flange_b.phi - flange_a.phi)) [rad/s]",\
 "gearbox.w_rel", 1, 1, 4, 0)
DeclareAlias2("gearbox.elastoBacklash.w_rel", "Relative angular velocity (= der(phi_rel)) [rad/s]",\
 "gearbox.w_rel", 1, 1, 4, 0)
DeclareAlias2("gearbox.elastoBacklash.der(w_rel)", "der(Relative angular velocity (= der(phi_rel))) [rad/s2]",\
 "gearbox.der(w_rel)", 1, 6, 4, 0)
DeclareAlias2("gearbox.elastoBacklash.a_rel", "Relative angular acceleration (= der(w_rel)) [rad/s2]",\
 "gearbox.der(w_rel)", 1, 6, 4, 0)
DeclareAlias2("gearbox.elastoBacklash.tau", "Torque between flanges (= flange_b.tau) [N.m]",\
 "gearbox.flange_b.tau", 1, 5, 42, 0)
DeclareAlias2("gearbox.elastoBacklash.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "gearbox.lossyGear.flange_b.phi", 1, 5, 54, 4)
DeclareAlias2("gearbox.elastoBacklash.flange_a.tau", "Cut torque in the flange [N.m]",\
 "gearbox.flange_b.tau", -1, 5, 42, 132)
DeclareAlias2("gearbox.elastoBacklash.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 5, 4)
DeclareAlias2("gearbox.elastoBacklash.flange_b.tau", "Cut torque in the flange [N.m]",\
 "gearbox.flange_b.tau", 1, 5, 42, 132)
DeclareVariable("gearbox.elastoBacklash.phi_nominal", "Nominal value of phi_rel (used for scaling) [rad|rad]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("gearbox.elastoBacklash.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 4, 1.0,5.0,0.0,0,1541)
DeclareVariable("gearbox.elastoBacklash.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("gearbox.elastoBacklash.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("gearbox.elastoBacklash.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "gearbox.elastoBacklash.lossPower", -1, 5, 120, 132)
DeclareVariable("gearbox.elastoBacklash.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.elastoBacklash.bMax", "Backlash in range bMin <= phi_rel - phi_rel0 <= bMax [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.elastoBacklash.bMin", "Backlash in range bMin <= phi_rel - phi_rel0 <= bMax [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.elastoBacklash.tau_c", "[N.m]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("gearbox.elastoBacklash.tau_d", "[N.m]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("gearbox.elastoBacklash.phi_diff", "[rad|deg]", "gearbox.phi_rel", 1,\
 1, 3, 1024)
DeclareVariable("gearbox.elastoBacklash.bEps", "Minimum backlash [rad|deg]", \
1E-10, 0.0,0.0,0.0,0,2561)
DeclareAlias2("feedback.u1", "[rad]", "step.y", 1, 5, 40, 0)
DeclareAlias2("feedback.u2", "[rad]", "inertia.phi", 1, 1, 5, 0)
DeclareAlias2("feedback.y", "[rad]", "PID.u", 1, 5, 21, 0)
DeclareAlias2("inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 5, 4)
DeclareAlias2("inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"gearbox.flange_b.tau", -1, 5, 42, 132)
DeclareAlias2("inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 5, 4)
DeclareVariable("inertia.flange_b.tau", "Cut torque in the flange [N.m]", 0, \
0.0,0.0,0.0,0,777)
DeclareParameter("inertia.J", "Moment of inertia [kg.m2]", 32, 5, 0.0,1E+100,0.0,\
0,560)
DeclareVariable("inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareState("inertia.phi", "Absolute rotation angle of component [rad|deg]", 5,\
 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 6, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "inertia.der(w)", 1, 6, 6, 0)
DeclareAlias2("angleSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 5, 4)
DeclareVariable("angleSensor.flange.tau", "Cut torque in the flange [N.m]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("angleSensor.phi", "Absolute angle of flange as output signal [rad|deg]",\
 "inertia.phi", 1, 1, 5, 0)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
preD(DYNX(W_,102),"gearbox.lossyGear.mode", 2, 0);
EndPreBlock
StartEqBlock
DoRemember_(DYNX(F_,0), 0.0, 1);
DoRemember_(DYNX(W_,67), 0.0, 4);
DoRemember_(DYNX(F_,6), 0.0, 0);
DoRemember_(DYNX(W_,68), 0.0, 2);
DoRemember_(DYNX(W_,87), 0.0, 3);
EndEqBlock
EndDataBlock
