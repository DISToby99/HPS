#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model FM3217_Assignment2022.YourSubLibrary.PowerConverters.Examples.PowerConverter1Diode
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Mon Oct 31 13:04:34 2022

   */

#include <matrixop.h>
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    0
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    28
#define NP_    17
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -452886787
#define NHash2_ -958291069
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    22
#define SizePre_ 0
#define SizeEq_ 1
#define SizeDelay_ 0
#define QNLmax_ 1
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 43
#define NGlobalHelpI_ 23
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="FM3217_Assignment2022.YourSubLibrary.PowerConverters.Examples.PowerConverter1Diode";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/toma/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1) = false;
DYNX(W_,3) = false;
DYNX(W_,16) = false;
DYNX(W_,13) = 0;
DYNX(W_,12) = 0;
DYNX(W_,14) = 0;
DYNX(W_,20) = 0.0;
DYNX(W_,15) = 0.0;
DYNX(W_,22) = 0.0;
DYNX(W_,21) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,7) > 0,"diode.diode1.T > 0", "Temperature must be positive");
BoundParameterSection
DYNX(W_,2) = DYNX(DP_,8);
DYNX(W_,17) = DYNX(DP_,10);
AssertModelica(1+DYNX(DP_,11)*(DYNX(W_,17)-DYNX(DP_,10)) >= 1E-15,
  "1+resistor.alpha*(resistor.T-resistor.T_ref) >= 1E-15", "Temperature outside scope of model!");
DYNX(W_,23) = DYNX(DP_,12);
DYNX(W_,24) = DYNX(DP_,14);
DYNX(W_,25) = DYNX(DP_,13);
DYNX(W_,26) = DYNX(DP_,15);
DYNX(W_,27) = DYNX(DP_,16);
BoundParameterConstantSection
DYNX(W_,19) = DYNX(DP_,9)*(1+DYNX(DP_,11)*(DYNX(W_,17)-DYNX(DP_,10)));
DYNX(W_,5) = 8.617333262145179E-05*DYNX(DP_,7);
DYNX(DYNhelp,0) = divinvGuarded(DYNX(DP_,5),"diode.diode1.TNOM");
DYNX(DYNhelp,1) = DYNX(DP_,4)*DYNX(W_,5);
DYNX(W_,7) = divGuarded((DYNX(DYNhelp,0)*DYNX(DP_,7)-1)*DYNX(DP_,3),
  "(diode.diode1.T/diode.diode1.TNOM-1)*diode.diode1.EG",DYNX(DYNhelp,1),
  "diode.diode1.N*diode.diode1.vt_t");
DYNX(W_,8) = exp(DYNX(W_,7));
BoundParameterSection
InitialSection
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,21) = 0.0;
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection

AcceptedSection1

AcceptedSection2
DYNX(W_,9) = DYNX(W_,26)+(IF LessTime(DYNX(W_,27), 0) THEN 0 ELSE DYNX(W_,23)*
  sin(6.283185307179586*DYNX(W_,24)*(DYNTime-DYNX(W_,27))+DYNX(W_,25)));

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 11 common subexpressions used in 6 expressions */
/* Of the common subexpressions 10 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"diode.diode1.v"};
const double nominal_[]={1};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 1, 0, 0, 1, -2, 1, 
  DYNX(DYNhelp,2), 37, DYNX(did_->helpvari_vec,0), 23);
NonLinearSystemSave(DYNX(W_,9), 0);
SetInitVectorNH(x__, 1, DYNX(W_,0), Remember_(DYNX(W_,0), 0));
Residues;
  if (NewParameters_) {
  DYNX(DYNhelp,39) = divinvGuarded(DYNX(W_,2),"diode.diode1.Vt");
  }
  DYNX(DYNhelp,40) = DYNX(DYNhelp,39)*DYNX(W_,0);
  DYNX(DYNhelp,41) = DYNX(DYNhelp,40) > DYNX(DP_,1);
  DYNX(W_,6) = DYNX(DP_,0)*((IF DYNX(DYNhelp,41) THEN exp(DYNX(DP_,1))*(1.0+
    DYNX(DYNhelp,40)-DYNX(DP_,1)) ELSE exp(DYNX(DYNhelp,40)))-1);
  if (NewParameters_) {
  DYNX(DYNhelp,42) = divinvGuarded(DYNX(DP_,2),"diode.diode1.R");
  }
  DYNX(W_,10) = DYNX(W_,6)+DYNX(DYNhelp,42)*DYNX(W_,0);
  DYNX(W_,11) = DYNX(W_,19)*DYNX(W_,10);
SetVector(residue__, 1, DYNX(W_,0)-DYNX(W_,9)+DYNX(W_,11));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1, 1.0+DYNX(W_,19)*DYNX(DP_,0)*(IF 
  DYNX(DYNhelp,41) THEN DYNX(DYNhelp,39)*exp(DYNX(DP_,1)) ELSE DYNX(DYNhelp,39)*
  exp(DYNX(DYNhelp,40)))+DYNX(W_,19)*DYNX(DYNhelp,42));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 1, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,0) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsNH(residue__, x__, 1);
 /* End of Non-Linear Equation Block */ }



DYNX(W_,4) = DYNX(W_,10)*DYNX(W_,0);
DYNX(W_,18) = DYNX(W_,11)*DYNX(W_,10);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("diode.diode1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,576)
DeclareAlias2("diode.diode1.p.v", "Potential at the pin [V]", "diode.p1.v", 1, 5,\
 9, 4)
DeclareAlias2("diode.diode1.p.i", "Current flowing into the pin [A]", \
"diode.p1.i", 1, 5, 10, 132)
DeclareAlias2("diode.diode1.n.v", "Potential at the pin [V]", "diode.n1.v", 1, 5,\
 11, 4)
DeclareAlias2("diode.diode1.n.i", "Current flowing into the pin [A]", \
"diode.p1.i", -1, 5, 10, 132)
DeclareAlias2("diode.diode1.i", "Current flowing from pin p to pin n [A]", \
"diode.p1.i", 1, 5, 10, 0)
DeclareParameter("diode.diode1.Ids", "Saturation current [A]", 0, 1E-06, \
0.0,0.0,0.0,0,560)
DeclareVariable("diode.diode1.useTemperatureDependency", "= true, if the diode current depends on temperature, otherwise utilizes the voltage equivalent of temperature [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("diode.diode1.Vt", "Voltage equivalent of temperature (kT/qn) [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("diode.diode1.Maxexp", "Max. exponent for linear continuation",\
 1, 15, 1E-60,1E+100,0.0,0,560)
DeclareParameter("diode.diode1.R", "Parallel ohmic resistance [Ohm]", 2, \
100000000.0, 0.0,0.0,0.0,0,560)
DeclareParameter("diode.diode1.EG", "Activation energy", 3, 1.11, 0.0,0.0,0.0,0,560)
DeclareParameter("diode.diode1.N", "Emission coefficient", 4, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("diode.diode1.TNOM", "Parameter measurement temperature [K|degC]",\
 5, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("diode.diode1.XTI", "Temperature exponent of saturation current",\
 6, 3, 0.0,0.0,0.0,0,560)
DeclareVariable("diode.diode1.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("diode.diode1.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 7, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("diode.diode1.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("diode.diode1.T_heatPort", "Temperature of heatPort [K|degC]", \
"diode.diode1.T", 1, 7, 7, 0)
DeclareVariable("diode.diode1.vt_t", "Temperature voltage [V]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("diode.diode1.id", "Diode current [A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("diode.diode1.htemp", "Auxiliary temperature [K|degC]", \
"diode.diode1.T", 1, 7, 7, 1024)
DeclareVariable("diode.diode1.aux", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("diode.diode1.auxp", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("diode.diodeVoltage", "[v] The voltage drop over one diode (Total 4 diodes in the system) [V]",\
 8, 0.2, 0.0,0.0,0.0,0,560)
DeclareVariable("diode.p1.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("diode.p1.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,\
0.0,0,776)
DeclareVariable("diode.n1.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("diode.n1.i", "Current flowing into the pin [A]", "diode.p1.i", -1,\
 5, 10, 132)
DeclareAlias2("voltageSensor.p.v", "Potential at the pin [V]", "diode.n1.v", 1, 5,\
 11, 4)
DeclareVariable("voltageSensor.p.i", "Current flowing into the pin [A]", 0, \
0.0,0.0,0.0,0,777)
DeclareVariable("voltageSensor.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("voltageSensor.n.i", "Current flowing into the pin [A]", 0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("voltageSensor.v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 "diode.n1.v", 1, 5, 11, 0)
DeclareParameter("resistor.R", "Resistance at temperature T_ref [Ohm]", 9, 10, \
0.0,0.0,0.0,0,560)
DeclareParameter("resistor.T_ref", "Reference temperature [K|degC]", 10, 300.15,\
 0.0,1E+100,300.0,0,560)
DeclareParameter("resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 11, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]", \
"diode.n1.v", 1, 5, 11, 0)
DeclareAlias2("resistor.p.v", "Potential at the pin [V]", "diode.n1.v", 1, 5, 11,\
 4)
DeclareAlias2("resistor.p.i", "Current flowing into the pin [A]", "diode.p1.i", 1,\
 5, 10, 132)
DeclareVariable("resistor.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("resistor.n.i", "Current flowing into the pin [A]", "diode.p1.i", -1,\
 5, 10, 132)
DeclareAlias2("resistor.i", "Current flowing from pin p to pin n [A]", \
"diode.p1.i", 1, 5, 10, 0)
DeclareVariable("resistor.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("resistor.T_heatPort", "Temperature of heatPort [K|degC]", \
"resistor.T", 1, 5, 17, 0)
DeclareVariable("resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("ground.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("ground.p.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,\
0.0,0,777)
DeclareParameter("sineVoltage.V", "Amplitude of sine wave [V]", 12, 15, 0.0,0.0,\
0.0,0,560)
DeclareParameter("sineVoltage.phase", "Phase of sine wave [rad|deg]", 13, 0, \
0.0,0.0,0.0,0,560)
DeclareParameter("sineVoltage.f", "Frequency of sine wave [Hz]", 14, 50, \
0.0,0.0,0.0,0,560)
DeclareAlias2("sineVoltage.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "diode.p1.v", 1, 5, 9, 0)
DeclareAlias2("sineVoltage.p.v", "Potential at the pin [V]", "diode.p1.v", 1, 5,\
 9, 4)
DeclareAlias2("sineVoltage.p.i", "Current flowing into the pin [A]", \
"diode.p1.i", -1, 5, 10, 132)
DeclareVariable("sineVoltage.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,521)
DeclareAlias2("sineVoltage.n.i", "Current flowing into the pin [A]", \
"diode.p1.i", 1, 5, 10, 132)
DeclareAlias2("sineVoltage.i", "Current flowing from pin p to pin n [A]", \
"diode.p1.i", -1, 5, 10, 0)
DeclareVariable("sineVoltage.signalSource.amplitude", "Amplitude of sine wave [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("sineVoltage.signalSource.f", "Frequency of sine wave [Hz]", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("sineVoltage.signalSource.phase", "Phase of sine wave [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("sineVoltage.signalSource.y", "Connector of Real output signal [V]",\
 "diode.p1.v", 1, 5, 9, 0)
DeclareVariable("sineVoltage.signalSource.offset", "Offset of output signal y [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("sineVoltage.signalSource.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("sineVoltage.offset", "Voltage offset [V]", 15, 0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("sineVoltage.startTime", "Time offset [s]", 16, 0, 0.0,0.0,0.0,\
0,560)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRememAcc_(DYNX(W_,0), 0.0, 0);
EndEqBlock
EndDataBlock
