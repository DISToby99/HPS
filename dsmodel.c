#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model FM3217_2022.Tuturial3.Tests.DCGenerator
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Mon Sep 19 14:45:38 2022

   */

#include <matrixop.h>
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    5
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    39
#define NP_    14
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 1103762132
#define NHash2_ -1905927924
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    64
#define SizePre_ 0
#define SizeEq_ 5
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="FM3217_2022.Tuturial3.Tests.DCGenerator";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/toma/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[11]={3 , 2 , 1 , 2 , 2 , 3 , 4 , 1 , 5 , 0 , 0};
DYMOLA_STATIC int QJacobianGC_[16]={
1 , 0 , 1 , 0 , 1 , 3 , 3 , 0 , 0 , 4 , 5 , 0 , 0 , 5 , 5 , 0};
DYMOLA_STATIC double QJacobianCD_[6]={0  , 44 , 55 , 60 , 70 , 72};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,3) = false;
DYNX(W_,12) = false;
DYNX(W_,17) = 3;
DYNX(W_,24) = false;
DYNX(W_,35) = 3;
DYNX(W_,36) = false;
DYNX(W_,19) = 0;
DYNX(W_,37) = 0;
DYNX(W_,15) = 0.0;
DYNX(W_,7) = 0.0;
DYNX(W_,32) = 0.0;
DYNX(W_,29) = 0.0;
DYNX(W_,28) = 0.0;
DYNX(W_,23) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,0) = DYNX(DP_,0);
DYNX(W_,4) = DYNX(DP_,3);
AssertModelica(1+DYNX(DP_,4)*(DYNX(W_,4)-DYNX(DP_,3)) >= 1E-15,"1+dCMachine.Ra.alpha*(dCMachine.Ra.T-dCMachine.Ra.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,11) = DYNX(DP_,1);
DYNX(W_,16) = DYNX(DP_,2);
DYNX(W_,21) = DYNX(DP_,9);
DYNX(W_,25) = DYNX(DP_,7);
AssertModelica(1+DYNX(DP_,8)*(DYNX(W_,25)-DYNX(DP_,7)) >= 1E-15,"1+rLC_Load.resistor.alpha*(rLC_Load.resistor.T-rLC_Load.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,30) = DYNX(DP_,10);
DYNX(W_,33) = DYNX(DP_,11);
DYNX(W_,34) = DYNX(DP_,12);
DYNX(W_,38) = DYNX(DP_,13);
BoundParameterConstantSection
DYNX(W_,6) = DYNX(W_,0)*(1+DYNX(DP_,4)*(DYNX(W_,4)-DYNX(DP_,3)));
DYNX(W_,27) = DYNX(W_,21)*(1+DYNX(DP_,8)*(DYNX(W_,25)-DYNX(DP_,7)));
BoundParameterSection
InitialSection
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
 /* Linear system of equations to solve. */
DYNX(F_,3) = RememberSimple_(DYNX(F_,3), 0);
SolveScalarLinearParametric(DYNX(W_,30),"rLC_Load.inductor.L", DYNX(X_,4),
  "rLC_Load.capacitor1.v", DYNX(F_,3),"der(rLC_Load.inductor.i)");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
DYNX(W_,22) = RememberSimple_(DYNX(W_,22), 1);
SolveScalarLinearParametric( -DYNX(W_,27)," -rLC_Load.resistor.R_actual",  -
  DYNX(X_,4)," -rLC_Load.capacitor1.v", DYNX(W_,22),"rLC_Load.resistor.i");
 /* End of Equation Block */ 

DYNX(W_,31) =  -(DYNX(X_,3)-DYNX(X_,0)+DYNX(W_,22));
 /* Linear system of equations to solve. */
DYNX(F_,4) = RememberSimple_(DYNX(F_,4), 2);
SolveScalarLinearParametric( -DYNX(W_,33)," -rLC_Load.capacitor1.C",  -
  DYNX(W_,31)," -rLC_Load.capacitor1.i", DYNX(F_,4),"der(rLC_Load.capacitor1.v)");
 /* End of Equation Block */ 

DYNX(W_,1) = DYNX(W_,6)*DYNX(X_,0);
DYNX(W_,2) =  -(DYNX(W_,1)+DYNX(X_,4));
DYNX(W_,10) = DYNX(DP_,5)*DYNX(X_,2);
DYNX(W_,9) = DYNX(W_,2)-DYNX(W_,10);
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 3);
SolveScalarLinearParametric(DYNX(W_,11),"dCMachine.La.L", DYNX(W_,9),
  "dCMachine.La.v", DYNX(F_,0),"der(dCMachine.La.i)");
 /* End of Equation Block */ 

DYNX(W_,14) =  -DYNX(DP_,5)*DYNX(X_,0);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[1] */
DYNX(F_,2) = RememberSimple_(DYNX(F_,2), 4);
SolveScalarLinearParametric(DYNX(W_,34)+DYNX(W_,16),"turbine.inertia.J+dCMachine.inertia.J",
   DYNX(W_,38)-DYNX(W_,14),"turbine.constantTorque.tau_constant-dCMachine.emf.tau",
   DYNX(F_,2),"der(dCMachine.inertia.w)");
DYNX(W_,18) = DYNX(W_,16)*DYNX(F_,2)+DYNX(W_,14);
 /* End of Equation Block */ 

DYNX(F_,1) = DYNX(X_,2);

AcceptedSection1

AcceptedSection2
DYNX(W_,13) = DYNX(X_,1)-DYNX(DP_,6);
DYNX(W_,5) = DYNX(W_,1)*DYNX(X_,0);
DYNX(W_,20) =  -(DYNX(W_,31)+DYNX(X_,3)+DYNX(W_,22));
DYNX(W_,8) = DYNX(W_,20)+DYNX(X_,0);
DYNX(W_,26) = DYNX(X_,4)*DYNX(W_,22);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("dCMachine.R", "Resitance of the armature [Ohm]", 0, 0.5, \
0.0,0.0,0.0,0,560)
DeclareParameter("dCMachine.L", "Inductance of the DC Machine [H]", 1, 0.1, \
0.0,0.0,0.0,0,560)
DeclareParameter("dCMachine.J", "Inertia for DC Machine [kg.m2]", 2, 0.5, \
0.0,0.0,0.0,0,560)
DeclareVariable("dCMachine.Ra.R", "Resistance at temperature T_ref [Ohm]", 1, \
0.0,0.0,0.0,0,513)
DeclareParameter("dCMachine.Ra.T_ref", "Reference temperature [K|degC]", 3, \
300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("dCMachine.Ra.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 4, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("dCMachine.Ra.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCMachine.Ra.i", "Current flowing from pin p to pin n [A]", \
"dCMachine.La.i", 1, 1, 0, 0)
DeclareAlias2("dCMachine.Ra.p.v", "Potential at the pin [V]", "rLC_Load.capacitor1.v", -1,\
 1, 4, 4)
DeclareAlias2("dCMachine.Ra.p.i", "Current flowing into the pin [A]", \
"dCMachine.La.i", 1, 1, 0, 132)
DeclareVariable("dCMachine.Ra.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("dCMachine.Ra.n.i", "Current flowing into the pin [A]", \
"dCMachine.La.i", -1, 1, 0, 132)
DeclareVariable("dCMachine.Ra.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("dCMachine.Ra.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("dCMachine.Ra.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCMachine.Ra.T_heatPort", "Temperature of heatPort [K|degC]", \
"dCMachine.Ra.T", 1, 5, 4, 0)
DeclareVariable("dCMachine.Ra.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("dCMachine.ground.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("dCMachine.ground.p.i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("dCMachine.La.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("dCMachine.La.i", "Current flowing from pin p to pin n [A]", 0, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("dCMachine.La.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCMachine.La.p.v", "Potential at the pin [V]", "dCMachine.Ra.n.v", 1,\
 5, 2, 4)
DeclareAlias2("dCMachine.La.p.i", "Current flowing into the pin [A]", \
"dCMachine.La.i", 1, 1, 0, 132)
DeclareVariable("dCMachine.La.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("dCMachine.La.n.i", "Current flowing into the pin [A]", \
"dCMachine.La.i", -1, 1, 0, 132)
DeclareVariable("dCMachine.La.L", "Inductance [H]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("dCMachine.emf.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("dCMachine.emf.k", "Transformation coefficient [N.m/A]", 5, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("dCMachine.emf.v", "Voltage drop between the two pins [V]", \
"dCMachine.La.n.v", 1, 5, 10, 0)
DeclareAlias2("dCMachine.emf.i", "Current flowing from positive to negative pin [A]",\
 "dCMachine.La.i", 1, 1, 0, 0)
DeclareVariable("dCMachine.emf.phi", "Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCMachine.emf.der(phi)", "der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "dCMachine.inertia.w", 1, 1, 2, 0)
DeclareAlias2("dCMachine.emf.w", "Angular velocity of flange relative to support [rad/s]",\
 "dCMachine.inertia.w", 1, 1, 2, 0)
DeclareVariable("dCMachine.emf.tau", "Torque of flange [N.m]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareAlias2("dCMachine.emf.tauElectrical", "Electrical torque [N.m]", \
"dCMachine.emf.tau", -1, 5, 14, 0)
DeclareAlias2("dCMachine.emf.p.v", "Potential at the pin [V]", "dCMachine.La.n.v", 1,\
 5, 10, 4)
DeclareAlias2("dCMachine.emf.p.i", "Current flowing into the pin [A]", \
"dCMachine.La.i", 1, 1, 0, 132)
DeclareVariable("dCMachine.emf.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("dCMachine.emf.n.i", "Current flowing into the pin [A]", \
"dCMachine.La.i", -1, 1, 0, 132)
DeclareAlias2("dCMachine.emf.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("dCMachine.emf.flange.tau", "Cut torque in the flange [N.m]", \
"dCMachine.emf.tau", 1, 5, 14, 132)
DeclareParameter("dCMachine.emf.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 6, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("dCMachine.emf.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.emf.fixed.phi0", 1, 7, 6, 1028)
DeclareAlias2("dCMachine.emf.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 "dCMachine.emf.tau", 1, 5, 14, 1156)
DeclareAlias2("dCMachine.emf.internalSupport.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "dCMachine.emf.tau", -1, 5, 14, 1024)
DeclareAlias2("dCMachine.emf.internalSupport.phi", "External support angle (= flange.phi) [rad|deg]",\
 "dCMachine.emf.fixed.phi0", 1, 7, 6, 1024)
DeclareAlias2("dCMachine.emf.internalSupport.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.emf.fixed.phi0", 1, 7, 6, 1028)
DeclareAlias2("dCMachine.emf.internalSupport.flange.tau", "Cut torque in the flange [N.m]",\
 "dCMachine.emf.tau", -1, 5, 14, 1156)
DeclareAlias2("dCMachine.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("dCMachine.inertia.flange_a.tau", "Cut torque in the flange [N.m]",\
 "dCMachine.emf.tau", -1, 5, 14, 132)
DeclareAlias2("dCMachine.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("dCMachine.inertia.flange_b.tau", "Cut torque in the flange [N.m]",\
 "dCMachine.y.tau", 1, 5, 18, 132)
DeclareVariable("dCMachine.inertia.J", "Moment of inertia [kg.m2]", 1, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("dCMachine.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareState("dCMachine.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 1, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("dCMachine.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("dCMachine.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 2, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("dCMachine.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("dCMachine.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "dCMachine.inertia.der(w)", 1, 6, 2, 0)
DeclareAlias2("dCMachine.y.phi", "Absolute rotation angle of flange [rad|deg]", \
"dCMachine.inertia.phi", 1, 1, 1, 4)
DeclareVariable("dCMachine.y.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("dCMachine.p.v", "Potential at the pin [V]", "rLC_Load.capacitor1.v", -1,\
 1, 4, 4)
DeclareAlias2("dCMachine.p.i", "Current flowing into the pin [A]", \
"dCMachine.La.i", 1, 1, 0, 132)
DeclareVariable("dCMachine.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("dCMachine.n.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("rLC_Load.resistor.R", "Resistance at temperature T_ref [Ohm]", 1,\
 0.0,0.0,0.0,0,513)
DeclareParameter("rLC_Load.resistor.T_ref", "Reference temperature [K|degC]", 7,\
 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("rLC_Load.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 8, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("rLC_Load.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "rLC_Load.capacitor1.v", 1, 1, 4, 0)
DeclareVariable("rLC_Load.resistor.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("rLC_Load.resistor.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("rLC_Load.resistor.p.i", "Current flowing into the pin [A]", \
"rLC_Load.resistor.i", 1, 5, 22, 132)
DeclareAlias2("rLC_Load.resistor.n.v", "Potential at the pin [V]", \
"rLC_Load.capacitor1.v", -1, 1, 4, 4)
DeclareAlias2("rLC_Load.resistor.n.i", "Current flowing into the pin [A]", \
"rLC_Load.resistor.i", -1, 5, 22, 132)
DeclareVariable("rLC_Load.resistor.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("rLC_Load.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("rLC_Load.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("rLC_Load.resistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "rLC_Load.resistor.T", 1, 5, 25, 0)
DeclareVariable("rLC_Load.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("rLC_Load.p1.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("rLC_Load.p1.i", "Current flowing into the pin [A]", \
"dCMachine.n.i", -1, 5, 20, 132)
DeclareAlias2("rLC_Load.n1.v", "Potential at the pin [V]", "rLC_Load.capacitor1.v", -1,\
 1, 4, 4)
DeclareAlias2("rLC_Load.n1.i", "Current flowing into the pin [A]", \
"dCMachine.La.i", -1, 1, 0, 132)
DeclareParameter("rLC_Load.Load", "Reactance of load [Ohm]", 9, 20, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("rLC_Load.inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "rLC_Load.capacitor1.v", 1, 1, 4, 0)
DeclareState("rLC_Load.inductor.i", "Current flowing from pin p to pin n [A]", 3,\
 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("rLC_Load.inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("rLC_Load.inductor.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("rLC_Load.inductor.p.i", "Current flowing into the pin [A]", \
"rLC_Load.inductor.i", 1, 1, 3, 132)
DeclareAlias2("rLC_Load.inductor.n.v", "Potential at the pin [V]", \
"rLC_Load.capacitor1.v", -1, 1, 4, 4)
DeclareAlias2("rLC_Load.inductor.n.i", "Current flowing into the pin [A]", \
"rLC_Load.inductor.i", -1, 1, 3, 132)
DeclareVariable("rLC_Load.inductor.L", "Inductance [H]", 1, 0.0,0.0,0.0,0,513)
DeclareParameter("rLC_Load.L", "Inducatnce of Load [H]", 10, 0.1, 0.0,0.0,0.0,0,560)
DeclareState("rLC_Load.capacitor1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 4, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("rLC_Load.capacitor1.der(v)", "der(Voltage drop of the two pins (= p.v - n.v)) [V/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("rLC_Load.capacitor1.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("rLC_Load.capacitor1.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("rLC_Load.capacitor1.p.i", "Current flowing into the pin [A]", \
"rLC_Load.capacitor1.i", 1, 5, 31, 132)
DeclareAlias2("rLC_Load.capacitor1.n.v", "Potential at the pin [V]", \
"rLC_Load.capacitor1.v", -1, 1, 4, 4)
DeclareAlias2("rLC_Load.capacitor1.n.i", "Current flowing into the pin [A]", \
"rLC_Load.capacitor1.i", -1, 5, 31, 132)
DeclareVariable("rLC_Load.capacitor1.C", "Capacitance [F]", 1, 0.0,1E+100,0.0,0,513)
DeclareParameter("rLC_Load.C", "Capacitance of load [F]", 11, 0.003, 0.0,1E+100,\
0.0,0,560)
DeclareAlias2("turbine.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("turbine.inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"dCMachine.y.tau", -1, 5, 18, 132)
DeclareAlias2("turbine.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("turbine.inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
"turbine.constantTorque.tau_constant", 1, 5, 38, 132)
DeclareVariable("turbine.inertia.J", "Moment of inertia [kg.m2]", 1, 0.0,1E+100,\
0.0,0,513)
DeclareVariable("turbine.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("turbine.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 0)
DeclareAlias2("turbine.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "dCMachine.inertia.w", 1, 1, 2, 0)
DeclareAlias2("turbine.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "dCMachine.inertia.w", 1, 1, 2, 0)
DeclareAlias2("turbine.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "dCMachine.inertia.der(w)", 1, 6, 2, 0)
DeclareAlias2("turbine.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "dCMachine.inertia.der(w)", 1, 6, 2, 0)
DeclareVariable("turbine.constantTorque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("turbine.constantTorque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("turbine.constantTorque.flange.tau", "Cut torque in the flange [N.m]",\
 "turbine.constantTorque.tau_constant", -1, 5, 38, 132)
DeclareVariable("turbine.constantTorque.phi_support", "Absolute angle of support flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("turbine.constantTorque.phi", "Angle of flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 0)
DeclareAlias2("turbine.constantTorque.der(phi)", "der(Angle of flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "dCMachine.inertia.w", 1, 1, 2, 0)
DeclareVariable("turbine.constantTorque.tau_constant", "Constant torque (if negative, torque is acting as load in positive direction of rotation) [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("turbine.constantTorque.w", "Angular velocity of flange with respect to support (= der(phi)) [rad/s]",\
 "dCMachine.inertia.w", 1, 1, 2, 0)
DeclareAlias2("turbine.constantTorque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "turbine.constantTorque.tau_constant", 1, 5, 38, 0)
DeclareAlias2("turbine.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "dCMachine.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("turbine.flange_a.tau", "Cut torque in the flange [N.m]", \
"dCMachine.y.tau", -1, 5, 18, 132)
DeclareParameter("turbine.J_t", "Trubine inertia [kg.m2]", 12, 2, 0.0,0.0,0.0,0,560)
DeclareParameter("turbine.T_t", "Trubine troque [kg.m2/s]", 13, 10, 0.0,0.0,0.0,\
0,560)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(F_,0), 0.0, 3);
DoRemember_(DYNX(F_,2), 0.0, 4);
DoRemember_(DYNX(F_,4), 0.0, 2);
DoRemember_(DYNX(F_,3), 0.0, 0);
DoRemember_(DYNX(W_,22), 0.0, 1);
EndEqBlock
EndDataBlock
